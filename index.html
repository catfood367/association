<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<title>Treino de associa√ß√£o (FSRS)</title>
<style>
    :root {
        --bg-light: #f5f5f5;
        --text-light: #000000;
        --bg-dark: #121212;
        --text-dark: #ffffff;
        --surface-light: #ffffff;
        --surface-dark: #333333;
        --primary: rgb(0, 138, 0);
        --secondary: rgb(0, 182, 173);
        --danger: rgb(220, 53, 69);
        --warning: rgb(255, 193, 7);
        --info: rgb(13, 110, 253);
    }
    
    body {
        margin: 0;
        padding: 0;
        background: var(--bg-light);
        color: var(--text-light);
        overflow: hidden;
        font-family: Arial, sans-serif;
        user-select: none;
        width: 100vw;
        height: 100vh;
        transition: background-color 0.3s ease, color 0.3s ease;
    }
    body.dark-mode {
        background: var(--bg-dark);
        color: var(--text-dark);
    }

    .modal {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.85);
        justify-content: center;
        align-items: center;
        flex-direction: column;
        z-index: 10000;
        font-family: 'Arial Black', Arial, sans-serif;
    }
    .modal-content {
        padding: 30px 40px;
        border-radius: 15px;
        text-align: center;
        color: var(--text-dark);
        max-width: 90vw;
        width: 500px;
        background: var(--surface-dark);
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        box-sizing: border-box;
    }
    .modal-content h1 {
        font-size: 2rem;
        margin-bottom: 20px;
    }
    .modal-content label {
        display: block;
        margin: 15px 0 5px;
        text-align: left;
        font-size: 1.1rem;
        font-weight: bold;
    }
    .modal-content input[type="text"],
    .modal-content input[type="range"],
    .modal-content select {
        width: 100%;
        margin-top: 5px;
        box-sizing: border-box;
    }
    .modal-content input[type="text"] {
        padding: 10px;
        border-radius: 8px;
        border: 2px solid #555;
        background: #444;
        color: white;
        font-size: 1rem;
    }
    .modal-content input[type="checkbox"] {
        width: 1.2em;
        height: 1.2em;
        margin-left: 10px;
        vertical-align: middle;
    }

    .btn, .btn-restart, .btn-close {
        margin: 10px 5px 0;
        font-size: 1rem;
        padding: 12px 22px;
        border: none;
        border-radius: 10px;
        color: white;
        font-weight: 900;
        cursor: pointer;
        transition: background-color 0.25s ease, transform 0.1s ease;
        user-select: none;
    }
    .btn:active {
        transform: scale(0.98);
    }
    .btn-primary { background: var(--primary); }
    .btn-primary:hover { background: rgb(0, 168, 0); }
    .btn-secondary { background: var(--secondary); }
    .btn-secondary:hover { background: rgb(0, 202, 193); }
    .btn-danger { background: var(--danger); }
    .btn-danger:hover { background: rgb(240, 73, 89); }
    .btn-warning { background: var(--warning); color: #000; }
    .btn-warning:hover { background: rgb(255, 203, 37); }
    .btn-close { background: var(--danger); }
    
    #voiceSelect {
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        background-color: var(--secondary);
        color: white;
        padding: 12px 20px;
        border: none;
        border-radius: 8px;
        max-width: 100%;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
    }
    #answerTipValue {
        display: inline-block;
        margin-left: 10px;
        font-weight: bold;
        width: 20px;
    }
    .modal-actions {
        display: flex;
        justify-content: space-between;
        margin-top: 10px;
        flex-wrap: wrap;
    }
    .modal-actions-sub {
        display: flex;
        justify-content: space-between;
        flex-wrap: wrap;
    }

    #deckModal {
        display: flex;
    }
    #deckModal .modal-content {
        background: var(--surface-dark);
    }
    #deckList {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 20px;
        padding: 20px;
        overflow-y: auto;
        height: calc(100% - 80px);
    }
    .deck-card {
        width: 180px;
        height: 250px;
        border: 2px solid #555;
        border-radius: 12px;
        background: #2a2a2a;
        color: white;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: 15px;
        box-sizing: border-box;
        transition: all 0.2s ease;
        position: relative;
    }
    .deck-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.4);
    }
    .deck-card-main {
        flex-grow: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        font-size: 1.3rem;
        font-weight: bold;
        cursor: pointer;
        overflow: hidden;
        word-break: break-word;
    }
    .deck-card-actions {
        display: flex;
        justify-content: space-around;
        padding-top: 10px;
        border-top: 1px solid #444;
    }
    .deck-action-btn {
        background: none;
        border: none;
        cursor: pointer;
        padding: 5px;
    }
    .deck-action-btn svg {
        width: 20px;
        height: 20px;
        fill: #999;
        transition: fill 0.2s ease;
    }
    .deck-action-btn:hover svg {
        fill: white;
    }
    #addDeckBtn {
        border-style: dashed;
        border-width: 3px;
        border-color: #555;
        cursor: pointer;
        background: #222;
    }
    #addDeckBtn:hover {
        background: #282828;
        border-color: #777;
    }
    #addDeckBtn .plus-sign {
        font-size: 80px;
        color: #555;
        line-height: 1;
        font-weight: 200;
        transition: color 0.2s ease;
    }
    #addDeckBtn:hover .plus-sign {
        color: #777;
    }

    #jsonEditorModal .modal-content {
        width: 80vw;
        max-width: 800px;
    }
    #jsonEditorTextarea {
        width: 100%;
        height: 50vh;
        border: 2px solid #555;
        border-radius: 8px;
        background: #2a2a2a;
        color: #f1f1f1;
        font-family: 'Courier New', Courier, monospace;
        font-size: 0.9rem;
        padding: 15px;
        box-sizing: border-box;
        resize:none;
        scrollbar-color: #45da00 #000000;
        scrollbar-width: thin;
    }
    #jsonEditorTextarea.invalid {
        border-color: var(--danger);
        box-shadow: 0 0 10px var(--danger);
    }

    #mergeModal .modal-content {
        width: 450px;
    }
    #mergeModal h2 {
        font-size: 1.5rem;
        margin-bottom: 20px;
    }
    #mergeModal p {
        font-size: 1.1rem;
    }

    #statsModal .modal-content {
        width: 450px;
        text-align: left;
    }
    #statsModal h1 {
        text-align: center;
    }
    #statsList {
        list-style: none;
        padding: 0;
        margin: 20px 0;
    }
    #statsList li {
        font-size: 1.2rem;
        padding: 10px 0;
        border-bottom: 1px solid #444;
        display: flex;
        justify-content: space-between;
    }
    #statsList li:last-child {
        border-bottom: none;
    }
    #statsList li span {
        font-weight: bold;
        color: var(--secondary);
    }
    #statsCloseBtn {
        display: block;
        margin: 20px auto 0;
    }
    
    #gameModeSettings fieldset {
        margin: 20px 0;
        border: 1px solid #555;
        border-radius: 8px;
        padding-bottom: 10px;
    }
    #gameModeSettings legend {
        font-size: 1.1rem;
        font-weight: bold;
        padding: 0 10px;
        color: var(--secondary);
        margin-left: 10px;
    }
    #gameModeSettings div {
        display: flex;
        justify-content: space-around;
        padding: 10px 0 0;
    }
    #gameModeSettings label {
        margin: 0;
        text-align: center;
        font-size: 1rem;
    }

    .syllable {
        position: absolute;
        font-size: 40px;
        font-weight: bold;
        text-align: left;
        line-height: 1.2;
        cursor: default;
        display: inline-block;
        color: var(--text-light);
    }
    body.dark-mode .syllable {
        color: var(--text-dark);
    }
    .translation {
        font-size: 30px;
        font-weight: bold;
        display: block;
        margin-top: 5px;
        white-space: nowrap;
        text-align: left;
        position: absolute;
        left: 0;
        top: 100%;
        color: var(--text-light);
    }
    body.dark-mode .translation {
        color: var(--text-dark);
    }

    #scorePanel {
        position: fixed;
        top: 10px;
        left: 10px;
        font-size: 20px;
        font-weight: bold;
        background: rgba(0,0,0,0.7);
        color: #fff;
        padding: 8px 15px;
        border-radius: 8px;
        z-index: 9999;
        user-select: none;
        font-family: 'Arial Black', Arial, sans-serif;
        display: flex;
        align-items: center;
        gap: 12px;
    }
    #currentDeckName {
        font-size: 0.9em;
        opacity: 0.8;
    }
    .panel-btn {
        cursor: pointer;
        background-color: transparent;
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
    }
    .panel-btn svg {
        width: 24px;
        height: 24px;
        fill: #fff;
        transition: fill 0.2s ease;
    }
    .panel-btn:hover svg {
        fill: var(--secondary);
    }

    #contextHintBox {
        display: none;
        position: fixed;
        top: 10px;
        right: 10px;
        background: rgba(13, 110, 253, 0.85);
        color: #fff;
        padding: 10px 15px;
        border-radius: 8px;
        z-index: 9998;
        font-family: Arial, sans-serif;
        font-size: 16px;
        font-weight: bold;
        align-items: center;
        max-width: 40%;
        box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    #contextHintBox svg {
        width: 20px;
        height: 20px;
        fill: #fff;
        margin-right: 10px;
        flex-shrink: 0;
    }
    #contextHintText {
        line-height: 1.4;
    }

    high {
        color: black;
    }

</style>
</head>
<body>

<div id="deckModal" class="modal">
    <div class="modal-content">
        <h1>Selecione um Deck</h1>
        <div id="deckList">
            <div id="addDeckBtn" class="deck-card">
                <div class="plus-sign">+</div>
            </div>
        </div>
    </div>
</div>

<div id="congratsModal" class="modal">
    <div class="modal-content">
        <h1>üéâ Parab√©ns! üéâ</h1>
        <p id="congratsMessage">Voc√™ terminou o jogo!!!</p>
        <button id="restartBtn" class="btn btn-primary">Reiniciar</button>
    </div>
</div>

<div id="statsModal" class="modal">
    <div class="modal-content">
        <h1 id="statsDeckName">Estat√≠sticas</h1>
        <ul id="statsList">
            <li>Total de Cart√µes: <span id="statsTotal">0</span></li>
            <li>Novos: <span id="statsNew">0</span></li>
            <li>Aprendendo: <span id="statsLearning">0</span></li>
            <li>Revis√£o: <span id="statsDue">0</span></li>
            <li>Maduros: <span id="statsMature">0</span></li>
        </ul>
        <button id="statsCloseBtn" class="btn btn-primary">Fechar</button>
    </div>
</div>

<div id="generalSettingsModal" class="modal">
    <div class="modal-content" style="width: 400px;">
        <h1>Op√ß√µes Gerais</h1>
        <br>
        <label>
            Som de Acerto:
            <input type="checkbox" id="generalCorrectSoundToggle" checked>
        </label>
        <label>
            Som de Erro:
            <input type="checkbox" id="generalWrongSoundToggle" checked>
        </label>
        <label>
            Modo Escuro:
            <input type="checkbox" id="generalDarkModeToggle">
        </label>

        <div class="modal-actions" style="margin-top: 30px; justify-content: center;">
            <button id="closeGeneralSettingsBtn" class="btn btn-primary">Fechar</button>
        </div>
    </div>
</div>

<div id="settingsModal" class="modal">
    <div class="modal-content">
        <label for="deckNameInput">Nome do Deck</label>
        <input type="text" id="deckNameInput" placeholder="Ex: Vocabul√°rio Japon√™s">
        
        <label style="margin-top: 15px;">
            Voz da leitura:
            <select id="voiceSelect"></select>
        </label>

        <div style="margin-top: 15px;">
            <label>
                Conte√∫do do Deck:
                <span id="fileName">Nenhum</span>
            </label>
            <button id="editJsonBtn" class="btn btn-secondary" style="width: 100%; margin: 0;">Editar/Importar JSON</button>
        </div>
        
        <hr style="border: 1px solid #555; margin: 20px 0;">

        <fieldset id="gameModeSettings">
            <legend>Modo de Jogo</legend>
            <div>
                <label>
                    Livre
                    <input type="checkbox" id="modeFreeToggle" name="gameMode" value="free">
                </label>
                <label>
                    FSRS
                    <input type="checkbox" id="modeFsrsToggle" name="gameMode" value="fsrs">
                </label>
                <label>
                    Pron√∫ncia
                    <input type="checkbox" id="modePronunciationToggle" name="gameMode" value="pronunciation">
                </label>
            </div>
        </fieldset>

        <br>
        
        <div id="freeModeSettingsDiv" style="display: none;">
            <label>
                Dica de Letras:
                <span id="answerTipValue">1</span>
                <input type="range" id="answerTipRange" min="0" max="3" value="1" step="1">
            </label>
            <label>
                Dica de Cor:
                <input type="checkbox" id="colorHintToggle" checked>
            </label>
            <label>
                Dica de Posi√ß√£o:
                <input type="checkbox" id="positionHintToggle" checked>
            </label>
            <label>
                Ordem Aleat√≥ria:
                <input type="checkbox" id="randomToggle">
            </label>
            <label>
                Reiniciar ao errar:
                <input type="checkbox" id="restartOnWrongToggle">
            </label>
        </div>

        <div class="modal-actions" style="margin-top: 30px;">
            <button id="cancelSettingsBtn" class="btn btn-danger">Cancelar</button>
            <button id="saveDeckBtn" class="btn btn-primary">Salvar</button>
        </div>
    </div>
</div>

<div id="jsonEditorModal" class="modal">
    <div class="modal-content">
        <h1>Editar Conte√∫do JSON</h1>
        <textarea id="jsonEditorTextarea" placeholder='[
    {
        "question": "palavra1",
        "answer": "word1",
        "contexts": ["Example phrase 1"]
    },
    {
        "question": "palavra2",
        "answer": "word2",
        "contexts": ["Example phrase 1", "Example **This becomes bold** 2"]
    }
]'></textarea>
        <div class="modal-actions">
            <button id="importJsonBtn" class="btn btn-secondary">Importar Arquivo...</button>
            <div class="modal-actions-sub">
                <button id="cancelJsonBtn" class="btn btn-danger">Cancelar</button>
                <button id="saveJsonBtn" class="btn btn-primary">Salvar</button>
            </div>
        </div>
    </div>
</div>

<div id="mergeModal" class="modal">
    <div class="modal-content" style="width: 600px !important;">
        <h2>Importar JSON</h2>
        <p>O editor j√° cont√©m dados. Voc√™ quer mesclar o novo arquivo ou sobrescrever?</p>
        <div class="modal-actions" style="margin-top: 20px !important;">
            <button id="cancelMergeBtn" class="btn btn-danger">Cancelar</button>
            <div class="modal-actions-sub" >
                <button id="overwriteBtn" class="btn btn-warning">Sobrescrever</button>
                 <button id="mergeBtn" class="btn btn-primary">Mesclar</button>
            </div>
        </div>
    </div>
</div>

<div id="scorePanel">
    <button id="deckSelectBtn" class="panel-btn" title="Voltar para sele√ß√£o de decks">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8v-6h-8v10zm0-18v6h8V3h-8z"/></svg>
    </button>
    <button id="settingsBtn" class="panel-btn" title="Configura√ß√µes do Deck Atual">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.08-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49.42l.38-2.65c.61-.25 1.17-.59 1.69.98l2.49 1c.23.08.49 0 .61.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></svg>
    </button>
    <button id="generalSettingsBtn" class="panel-btn" title="Op√ß√µes Gerais do Aplicativo">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8V7h-2v14h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z"/></svg>
    </button>
    <span id="currentDeckName">Nenhum Deck</span>
    <span id="scoreText">| Pontua√ß√£o: 0 | Level: 0 / 0</span>
</div>

<div id="contextHintBox">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg>
    <span id="contextHintText">Esta √© uma frase de contexto de exemplo.</span>
</div>

<input type="file" id="fileInput" accept=".json" style="display:none;">

<script>
(() => {
    const groupSize = 5;
    const DECK_STORAGE_KEY = 'association_game_decks_fsrs';
    const GLOBAL_SETTINGS_KEY = 'association_game_global_settings'; // Nova chave global
    const OLD_FILE_KEY = 'saved_file';
    const OLD_PREFS_KEY = 'user_preferences';

    let allDecks = [];
    let currentDeckId = null;
    let syllableList = [];
    let currentGroupIndex = 0;
    let currentGroup = [];
    let sessionReviewQueue = [];
    let currentSyllable = null;
    let currentSyllableElement = null;
    let translationElement = null;
    let userTyped = '';
    let score = 0;
    let hintUsed = false;
    let cardStartTime = 0;
    let firstKeyTime = 0;

    let selectedVoice = null;
    
    // Configura√ß√µes globais, n√£o mais por deck
    let correctSoundEnabled = true;
    let wrongSoundEnabled = true;
    let darkModeEnabled = false;

    // Configura√ß√µes espec√≠ficas do deck
    let randomToggleEnabled = false;
    let colorHintEnabled = true;
    let positionHintEnabled = true;
    let answerTipLetters = 1;
    let restartOnWrongEnabled = false;
    let evaluativeModeEnabled = false;
    let pronunciationModeEnabled = false;
    
    let utterance = null;
    let recognition = null;
    let isRecognizing = false;

    let editModeDeckId = null;
    let pendingDeckContent = null;
    let pendingFileName = null;
    let importCache = { content: null, name: null };

    const correctSound = new Audio('right.mp3');
    const wrongSound = new Audio('wrong.mp3');

    const dom = {
        scoreText: document.getElementById('scoreText'),
        fileInput: document.getElementById('fileInput'),
        fileNameSpan: document.getElementById('fileName'),
        currentDeckNameSpan: document.getElementById('currentDeckName'),
        contextHintBox: document.getElementById('contextHintBox'),
        contextHintText: document.getElementById('contextHintText'),
        deckModal: document.getElementById('deckModal'),
        settingsModal: document.getElementById('settingsModal'),
        congratsModal: document.getElementById('congratsModal'),
        congratsMessage: document.getElementById('congratsMessage'),
        jsonEditorModal: document.getElementById('jsonEditorModal'),
        mergeModal: document.getElementById('mergeModal'),
        statsModal: document.getElementById('statsModal'),
        settingsBtn: document.getElementById('settingsBtn'),
        deckSelectBtn: document.getElementById('deckSelectBtn'),
        deckList: document.getElementById('deckList'),
        addDeckBtn: document.getElementById('addDeckBtn'),
        editJsonBtn: document.getElementById('editJsonBtn'),
        saveDeckBtn: document.getElementById('saveDeckBtn'),
        cancelSettingsBtn: document.getElementById('cancelSettingsBtn'),
        deckNameInput: document.getElementById('deckNameInput'),
        randomToggle: document.getElementById("randomToggle"),
        colorHintToggle: document.getElementById("colorHintToggle"),
        positionHintToggle: document.getElementById("positionHintToggle"),
        restartOnWrongToggle: document.getElementById("restartOnWrongToggle"),
        voiceSelect: document.getElementById('voiceSelect'),
        answerTipRange: document.getElementById('answerTipRange'),
        answerTipValue: document.getElementById('answerTipValue'),
        freeModeSettingsDiv: document.getElementById('freeModeSettingsDiv'), // Div corrigida
        restartBtn: document.getElementById('restartBtn'),
        jsonEditorTextarea: document.getElementById('jsonEditorTextarea'),
        importJsonBtn: document.getElementById('importJsonBtn'),
        cancelJsonBtn: document.getElementById('cancelJsonBtn'),
        saveJsonBtn: document.getElementById('saveJsonBtn'),
        cancelMergeBtn: document.getElementById('cancelMergeBtn'),
        overwriteBtn: document.getElementById('overwriteBtn'),
        mergeBtn: document.getElementById('mergeBtn'),
        statsCloseBtn: document.getElementById('statsCloseBtn'),
        statsDeckName: document.getElementById('statsDeckName'),
        statsTotal: document.getElementById('statsTotal'),
        statsNew: document.getElementById('statsNew'),
        statsLearning: document.getElementById('statsLearning'),
        statsDue: document.getElementById('statsDue'),
        statsMature: document.getElementById('statsMature'),

        // Novos elementos
        generalSettingsBtn: document.getElementById('generalSettingsBtn'),
        generalSettingsModal: document.getElementById('generalSettingsModal'),
        generalCorrectSoundToggle: document.getElementById('generalCorrectSoundToggle'),
        generalWrongSoundToggle: document.getElementById('generalWrongSoundToggle'),
        generalDarkModeToggle: document.getElementById('generalDarkModeToggle'),
        closeGeneralSettingsBtn: document.getElementById('closeGeneralSettingsBtn'),
        
        // Novos toggles de modo
        modeFreeToggle: document.getElementById('modeFreeToggle'),
        modeFsrsToggle: document.getElementById('modeFsrsToggle'),
        modePronunciationToggle: document.getElementById('modePronunciationToggle')
    };

    // --- In√≠cio: Fun√ß√µes de Configura√ß√µes Globais ---

    function saveGlobalSettings() {
        const settings = {
            correctSoundEnabled: dom.generalCorrectSoundToggle.checked,
            wrongSoundEnabled: dom.generalWrongSoundToggle.checked,
            darkModeEnabled: dom.generalDarkModeToggle.checked
        };
        localStorage.setItem(GLOBAL_SETTINGS_KEY, JSON.stringify(settings));
        
        // Aplica imediatamente
        correctSoundEnabled = settings.correctSoundEnabled;
        wrongSoundEnabled = settings.wrongSoundEnabled;
        darkModeEnabled = settings.darkModeEnabled;
        document.body.classList.toggle('dark-mode', darkModeEnabled);
        
        if (currentSyllable) displaySyllable();
    }

    function loadGlobalSettings() {
        const settingsJson = localStorage.getItem(GLOBAL_SETTINGS_KEY);
        const s = settingsJson ? JSON.parse(settingsJson) : {
            correctSoundEnabled: true,
            wrongSoundEnabled: true,
            darkModeEnabled: false
        };
        
        correctSoundEnabled = s.correctSoundEnabled;
        wrongSoundEnabled = s.wrongSoundEnabled;
        darkModeEnabled = s.darkModeEnabled;

        dom.generalCorrectSoundToggle.checked = s.correctSoundEnabled;
        dom.generalWrongSoundToggle.checked = s.wrongSoundEnabled;
        dom.generalDarkModeToggle.checked = s.darkModeEnabled;

        document.body.classList.toggle('dark-mode', darkModeEnabled);
    }

    // --- Fim: Fun√ß√µes de Configura√ß√µes Globais ---
    function levenshtein(a, b) {
    const dp = Array.from({ length: a.length + 1 }, () =>
        Array(b.length + 1).fill(0)
    );

    for (let i = 0; i <= a.length; i++) dp[i][0] = i;
    for (let j = 0; j <= b.length; j++) dp[0][j] = j;

    for (let i = 1; i <= a.length; i++) {
        for (let j = 1; j <= b.length; j++) {
        const cost = a[i - 1] === b[j - 1] ? 0 : 1;
        dp[i][j] = Math.min(
            dp[i - 1][j] + 1,      // dele√ß√£o
            dp[i][j - 1] + 1,      // inser√ß√£o
            dp[i - 1][j - 1] + cost // substitui√ß√£o
        );
        }
    }

    return dp[a.length][b.length];
    }


// Normaliza uma palavra para ‚Äúpron√∫ncia‚Äù
function normalizePronunciation(word) {
    const russianPhoneticMap = {
  '—ë': '–µ',
  '–π': '–∏',
  '—ä': '',
  '—å': '',
  '—â': '—à',
  '—ã': '–∏',
  '—ç': '–µ',
  '—é': '—É',
  '—è': '–∞',
  // consoantes opcionais que podem confundir
  '—Ü': '—Ü',
  '–≥': '–≥',
  '—Ö': '—Ö',
  '—à': '—à',
  '–∂': '–∂',
  '—á': '—á'
  // adicione mais conforme necess√°rio
};
  return word
    .normalize('NFKC')
    .toLowerCase()
    .split('')
    .map(c => russianPhoneticMap[c] ?? c)
    .join('');
}

// Fun√ß√£o principal: verifica se duas palavras t√™m a mesma pron√∫ncia
function samePronunciation(word1, word2) {
  const norm1 = normalizePronunciation(word1);
  const norm2 = normalizePronunciation(word2);
  return norm1 === norm2;
}

    function calculateRetention(card) {
        if (!card.lastReview || card.s === undefined || card.s <= 0.1) return 1.0;
        const now = Date.now();
        const intervalDays = (now - card.lastReview) / (24 * 60 * 60 * 1000);
        return Math.exp(-intervalDays / card.s);
    }

    function calculateGrade(similarity, { reactionTime, typingTime }) {
        if (similarity < 0.7) return 0;
        if (similarity >= 0.7 && similarity < 1.0) return 1;

        if (similarity === 1) {
            const r = reactionTime / 1000;
            const t = typingTime / 1000;
            const total = r + t;
            const thinkingWhileTyping = t > r * 2 && t > 5;

            if (r < 2 && !thinkingWhileTyping) return 3;
            if (r < 4 && !thinkingWhileTyping) return 2;
            if (r < 6 && !thinkingWhileTyping) return 1;
            if (thinkingWhileTyping) return 0;
            if (total > 10) return 0;

            return 1;
        }
        return 0;
    }

    function updateFsrsData(card, grade) {
        card.s = card.s ?? 0.1;
        card.d = card.d ?? 0.5;
        
        if (grade === 0) {
            card.s = Math.max(0.1, card.s * 0.4);
        } else if (grade === 1) {
            card.s = Math.max(0.5, card.s * 1.1);
        } else if (grade === 2) {
            const factorGood = 0.8 * (1 - card.d);
            card.s = Math.max(1, (card.s + 1) * factorGood);
        } else {
            const factorEasy = 1.3 * (1 - card.d);
            card.s = Math.max(1, (card.s + 2) * factorEasy);
        }

        card.d = Math.max(0, Math.min(1, card.d + [0.1, 0.05, -0.05, -0.15][grade]));
        card.lastReview = Date.now();
        
        if (grade === 0) {
            card.dueDate = Date.now() + 2 * 60 * 1000;
        } else {
            card.dueDate = Date.now() + card.s * 24 * 60 * 60 * 1000;
        }
    }

    function pickFsrsCard() {
        const today = Date.now();
        const deck = allDecks.find(d => d.id === currentDeckId);
        if (!deck || !deck.content || deck.content.length === 0) return null;

        const queuedIds = new Set(sessionReviewQueue.map(c => c.id));
        const availableCards = deck.content.filter(c => !queuedIds.has(c.id));
        const cardsToConsider = availableCards.length > 0 ? availableCards : deck.content;

        const dueCards = cardsToConsider.filter(c => c.dueDate && c.dueDate <= today);
        if (dueCards.length > 0) {
            let bestCard = null;
            let minRetention = Infinity;
            for (const card of dueCards) {
                const retention = calculateRetention(card);
                if (retention < minRetention) {
                    minRetention = retention;
                    bestCard = card;
                }
            }
            return bestCard;
        }

        const newCards = cardsToConsider.filter(c => !c.lastReview);
        if (newCards.length > 0) {
            return newCards[Math.floor(Math.random() * newCards.length)];
        }

        if (sessionReviewQueue.length > 0) {
            return sessionReviewQueue.shift();
        }

        return null;
    }

    function calculateDeckStats(content) {
        const today = Date.now() + 2 * 60 * 1000;
        const stats = {
            total: content.length,
            newCount: 0,
            dueCount: 0,
            learningCount: 0,
            matureCount: 0
        };

        for (const card of content) {
            if (!card.lastReview) {
                stats.newCount++;
            } else {
                if (card.dueDate && card.dueDate <= today) stats.dueCount++;
                if (card.s < 7) stats.learningCount++;
                else if (card.s >= 21) stats.matureCount++;
            }
        }
        return stats;
    }

    function migrateDeckContentIfNeeded(deck) {
        if (!deck || !deck.content || deck.content.length === 0) return;

        if (deck.content[0].s === undefined) {
            console.log(`Migrando deck: ${deck.name}`);
            deck.content = deck.content.map(card => ({
                question: card.question,
                answer: card.answer,
                contexts: card.contexts || [],
                s: 0.1,
                d: 0.5,
                lastReview: null,
                dueDate: null
            }));
            saveDecks();
        }
    }

    function migrateOldData() {
        const oldFile = localStorage.getItem(OLD_FILE_KEY);
        const oldPrefs = localStorage.getItem(OLD_PREFS_KEY);

        if (oldFile && oldPrefs) {
            try {
                const fileData = JSON.parse(oldFile);
                const prefsData = JSON.parse(oldPrefs);

                // Migra configura√ß√µes globais
                if (!localStorage.getItem(GLOBAL_SETTINGS_KEY)) {
                    const globalSettings = {
                        correctSoundEnabled: prefsData.correctSoundEnabled ?? true,
                        wrongSoundEnabled: prefsData.wrongSoundEnabled ?? true,
                        darkModeEnabled: prefsData.darkModeEnabled ?? false
                    };
                    localStorage.setItem(GLOBAL_SETTINGS_KEY, JSON.stringify(globalSettings));
                }

                // Cria deck migrado com configura√ß√µes espec√≠ficas do deck
                const migratedDeck = {
                    id: 'migrated_' + Date.now(),
                    name: fileData.name || "Deck Migrado",
                    fileName: fileData.name || "Arquivo Migrado",
                    content: fileData.content,
                    settings: {
                        randomToggleEnabled: prefsData.randomToggleEnabled ?? false,
                        colorHintEnabled: prefsData.colorHintEnabled ?? true,
                        positionHintEnabled: prefsData.positionHintEnabled ?? true,
                        answerTipLetters: prefsData.answerTipLetters ?? 1,
                        restartOnWrongEnabled: prefsData.restartOnWrongEnabled ?? false,
                        evaluativeModeEnabled: false,
                        pronunciationModeEnabled: false, // Novo
                        voiceIndex: prefsData.voiceIndex ?? 'none'
                    }
                };
                
                allDecks.push(migratedDeck);
                saveDecks();

                localStorage.removeItem(OLD_FILE_KEY);
                localStorage.removeItem(OLD_PREFS_KEY);
            } catch (e) {
                console.error("Erro ao migrar dados antigos:", e);
            }
        }
    }

    function loadDecks() {
        const decksJson = localStorage.getItem(DECK_STORAGE_KEY);
        allDecks = decksJson ? JSON.parse(decksJson) : [];
    }

    function saveDecks() {
        localStorage.setItem(DECK_STORAGE_KEY, JSON.stringify(allDecks));
    }

    function renderDeckModal() {
        dom.deckList.innerHTML = '';

        allDecks.forEach(deck => {
            const card = document.createElement('div');
            card.className = 'deck-card';
            card.innerHTML = `
                <div class="deck-card-main" data-deck-id="${deck.id}">
                    ${deck.name}
                </div>
                <div class="deck-card-actions">
                    <button class="deck-action-btn stats" data-deck-id="${deck.id}" title="Estat√≠sticas">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 9.2h3V19H5zM10.6 5h2.8v14h-2.8zm5.6 8H19v6h-2.8z"/></svg>
                    </button>
                    <button class="deck-action-btn delete" data-deck-id="${deck.id}" title="Deletar Deck">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
                    </button>
                </div>
            `;
            dom.deckList.appendChild(card);
        });
        
        dom.deckList.appendChild(dom.addDeckBtn);

        document.querySelectorAll('.deck-card-main').forEach(btn => btn.addEventListener('click', handleSelectDeck));
        document.querySelectorAll('.deck-action-btn.stats').forEach(btn => btn.addEventListener('click', handleShowStats));
        document.querySelectorAll('.deck-action-btn.delete').forEach(btn => btn.addEventListener('click', handleDeleteDeck));
    }

    function handleSelectDeck(e) {
        const deckId = e.currentTarget.dataset.deckId;
        const selectedDeck = allDecks.find(d => d.id === deckId);

        if (!selectedDeck) return;
        
        migrateDeckContentIfNeeded(selectedDeck);
        
        if (!selectedDeck.content || selectedDeck.content.length === 0) {
            alert('Deck sem conte√∫do. Edite o deck para adicionar um.');
            return;
        }
        
        currentDeckId = deckId;
        syllableList = selectedDeck.content;

        applyDeckSettingsToGame(selectedDeck.settings);
        dom.currentDeckNameSpan.textContent = selectedDeck.name;
        dom.deckModal.style.display = 'none';
        startGame();
    }

    function handleEditDeck(e) {
        e.stopPropagation();
        const deckId = e.currentTarget.dataset.deckId;
        openSettingsModal(deckId);
    }
    
    function handleShowStats(e) {
        e.stopPropagation();
        const deckId = e.currentTarget.dataset.deckId;
        const deck = allDecks.find(d => d.id === deckId);
        if (!deck) return;

        migrateDeckContentIfNeeded(deck);
        const stats = calculateDeckStats(deck.content);
        
        dom.statsDeckName.textContent = `Estat√≠sticas: ${deck.name}`;
        dom.statsTotal.textContent = stats.total;
        dom.statsNew.textContent = stats.newCount;
        dom.statsLearning.textContent = stats.learningCount;
        dom.statsDue.textContent = stats.dueCount;
        dom.statsMature.textContent = stats.matureCount;
        
        dom.statsModal.style.display = 'flex';
    }

    function handleDeleteDeck(e) {
        e.stopPropagation();
        const deckId = e.currentTarget.dataset.deckId;
        if (confirm(`Tem certeza que quer deletar o deck "${allDecks.find(d => d.id === deckId).name}"?`)) {
            allDecks = allDecks.filter(d => d.id !== deckId);
            saveDecks();
            renderDeckModal();
            if (deckId === currentDeckId) {
                currentDeckId = null;
                dom.currentDeckNameSpan.textContent = "Nenhum Deck";
                if (currentSyllableElement) currentSyllableElement.remove();
                dom.contextHintBox.style.display = 'none';
            }
        }
    }

    // Nova fun√ß√£o para controlar visibilidade do Modo Livre
    function updateModeSettingsVisibility() {
        if (dom.modeFreeToggle.checked) {
            dom.freeModeSettingsDiv.style.display = 'block';
        } else {
            dom.freeModeSettingsDiv.style.display = 'none';
        }
    }
    
    function openSettingsModal(deckId = null) {
        if (deckId) {
            editModeDeckId = deckId;
            const deck = allDecks.find(d => d.id === deckId);
            if (!deck) return;

            migrateDeckContentIfNeeded(deck);
            
            dom.deckNameInput.value = deck.name;
            pendingDeckContent = deck.content ? JSON.stringify(deck.content) : null;
            pendingFileName = deck.fileName;
            dom.fileNameSpan.textContent = deck.fileName || 'Conte√∫do Salvo';
            applySettingsToModalUI(deck.settings);
        } else {
            editModeDeckId = null;
            dom.deckNameInput.value = '';
            pendingDeckContent = null;
            pendingFileName = null;
            dom.fileNameSpan.textContent = 'Nenhum';
            
            const defaults = readSettingsFromUI(); // Pega defaults da UI (que ser√£o os padr√µes)
            applySettingsToModalUI(defaults);
        }
        
        dom.settingsModal.style.display = 'flex';
    }

    function getDefaultSettings() {
        // Remove configs globais (som, dark mode)
        return {
            randomToggleEnabled: false,
            colorHintEnabled: true,
            positionHintEnabled: true,
            answerTipLetters: 1,
            restartOnWrongEnabled: false,
            evaluativeModeEnabled: false,
            pronunciationModeEnabled: false,
            voiceIndex: 'none'
        };
    }

    function applySettingsToModalUI(settings) {
        const s = settings || getDefaultSettings();
        
        // Configs do Modo Livre
        dom.randomToggle.checked = s.randomToggleEnabled;
        dom.colorHintToggle.checked = s.colorHintEnabled;
        dom.positionHintToggle.checked = s.positionHintEnabled;
        dom.restartOnWrongToggle.checked = s.restartOnWrongEnabled;
        dom.answerTipRange.value = s.answerTipLetters;
        dom.answerTipValue.textContent = s.answerTipLetters;
        
        // Configs de Modo de Jogo
        dom.modeFsrsToggle.checked = s.evaluativeModeEnabled;
        dom.modePronunciationToggle.checked = s.pronunciationModeEnabled;
        // Se nenhum estiver checado, checa o "Livre"
        dom.modeFreeToggle.checked = !s.evaluativeModeEnabled && !s.pronunciationModeEnabled;

        // Atualiza a visibilidade da div do modo livre
        updateModeSettingsVisibility();

        // Voz (continua por deck)
        setTimeout(() => {
            dom.voiceSelect.value = s.voiceIndex;
            if (!dom.voiceSelect.value && dom.voiceSelect.options.length > 0) {
                dom.voiceSelect.value = 'none';
            }
        }, 200);
    }

    function readSettingsFromUI() {
        // Remove configs globais (som, dark mode)
        return {
            randomToggleEnabled: dom.randomToggle.checked,
            colorHintEnabled: dom.colorHintToggle.checked,
            positionHintEnabled: dom.positionHintToggle.checked,
            answerTipLetters: parseInt(dom.answerTipRange.value),
            restartOnWrongEnabled: dom.restartOnWrongToggle.checked,
            evaluativeModeEnabled: dom.modeFsrsToggle.checked,
            pronunciationModeEnabled: dom.modePronunciationToggle.checked,
            voiceIndex: dom.voiceSelect.value
        };
    }
    
    function applyDeckSettingsToGame(settings) {
        // Configs globais (som, dark mode) s√£o aplicadas em loadGlobalSettings()
        
        // Configs espec√≠ficas do deck
        randomToggleEnabled = settings.randomToggleEnabled ?? false;
        colorHintEnabled = settings.colorHintEnabled ?? true;
        positionHintEnabled = settings.positionHintEnabled ?? true;
        answerTipLetters = settings.answerTipLetters ?? 1;
        restartOnWrongEnabled = settings.restartOnWrongEnabled ?? false;
        evaluativeModeEnabled = settings.evaluativeModeEnabled ?? false;
        pronunciationModeEnabled = settings.pronunciationModeEnabled ?? false;

        // Config de Voz
        if (settings.voiceIndex && settings.voiceIndex !== 'none') {
            setTimeout(() => {
                dom.voiceSelect.value = settings.voiceIndex;
                selectVoice();
                if (recognition && selectedVoice) {
                    recognition.lang = selectedVoice.lang;
                }
            }, 500);
        } else {
            dom.voiceSelect.value = 'none';
            selectVoice();
        }
    }
    
    function saveCurrentDeckSettings() {
        if (!currentDeckId) return;
        const deck = allDecks.find(d => d.id === currentDeckId);
        if (!deck) return;

        // Salva apenas configura√ß√µes do deck
        deck.settings = {
            randomToggleEnabled,
            colorHintEnabled,
            positionHintEnabled,
            answerTipLetters,
            restartOnWrongEnabled,
            evaluativeModeEnabled,
            pronunciationModeEnabled,
            voiceIndex: dom.voiceSelect.value
        };
        
        saveDecks();
    }

    function cleanJsonContent(contentArray) {
        return contentArray.map(card => {
            const q = (card.question || "").trim();
            const a = (card.answer || "").trim();
            if (q && a) {
                return { 
                    question: q, 
                    answer: a,
                    contexts: card.contexts || []
                };
            }
            return null;
        }).filter(item => item !== null);
    }

    function deduplicateCards(cards) {
        const qaKeys = new Set();
        let hasDuplicates = false;
        const filtered = cards.filter(card => {
            const q = (card.question || "").trim();
            const a = (card.answer || "").trim();
            if (q && a) {
                const key = q + "::" + a;
                if (qaKeys.has(key)) {
                    hasDuplicates = true;
                    return false;
                }
                qaKeys.add(key);
                return true;
            }
            return false;
        });
        
        if (hasDuplicates) {
            alert("Aten√ß√£o: Cart√µes duplicados (Mesma Pergunta e Resposta) foram removidos. Por favor, corrija o JSON para evitar a perda de dados FSRS.");
        }
        return filtered;
    }

    dom.saveDeckBtn.addEventListener('click', () => {
        const deckName = dom.deckNameInput.value.trim();
        if (!deckName) {
            alert('Por favor, d√™ um nome ao deck.');
            return;
        }
        
        const settings = readSettingsFromUI(); // L√™ apenas configs do deck
        
        let newContentBase = [];
        try {
            newContentBase = pendingDeckContent ? JSON.parse(pendingDeckContent) : [];
            if (!Array.isArray(newContentBase)) throw new Error('Conte√∫do JSON inv√°lido.');
        } catch (e) {
            alert("Erro ao salvar: Conte√∫do JSON parece ser inv√°lido.");
            return;
        }

        newContentBase = deduplicateCards(newContentBase);
        
        if (editModeDeckId) {
            const deck = allDecks.find(d => d.id === editModeDeckId);
            if (!deck) return;

            const oldContentWithFSRS = deck.content || [];
            const oldCardMap = new Map();
            
            oldContentWithFSRS.forEach(card => {
                const q = (card.question || "").trim();
                const a = (card.answer || "").trim();
                const key = q + "::" + a;
                if (q && a) oldCardMap.set(key, card);
            });
            
            const finalContent = newContentBase.map(newCard => {
                const q = (newCard.question || "").trim();
                const a = (newCard.answer || "").trim();
                const key = q + "::" + a;

                const matchedOldCard = oldCardMap.get(key);
                
                if (matchedOldCard) {
                    matchedOldCard.contexts = newCard.contexts || [];
                    return matchedOldCard;
                } else {
                    return {
                        question: q,
                        answer: a,
                        contexts: newCard.contexts || [],
                        s: 0.1,
                        d: 0.5,
                        lastReview: null,
                        dueDate: null
                    };
                }
            });

            deck.name = deckName;
            deck.settings = settings;
            deck.fileName = pendingFileName;
            deck.content = finalContent;
        } else {
            if (newContentBase.length === 0) {
                alert('Por favor, adicione conte√∫do JSON ao deck usando o bot√£o "Editar/Importar JSON".');
                return;
            }
            
            const newContentWithFSRS = newContentBase.map(card => ({
                question: (card.question || "").trim(),
                answer: (card.answer || "").trim(),
                contexts: card.contexts || [],
                s: 0.1,
                d: 0.5,
                lastReview: null,
                dueDate: null
            }));
            
            const newDeck = {
                id: 'deck_' + Date.now(),
                name: deckName,
                fileName: pendingFileName,
                content: newContentWithFSRS,
                settings: settings
            };
            allDecks.push(newDeck);
        }
        
        saveDecks();
        renderDeckModal();
        dom.settingsModal.style.display = 'none';

        if (editModeDeckId && editModeDeckId === currentDeckId) {
            const updatedDeck = allDecks.find(d => d.id === currentDeckId);
            syllableList = updatedDeck.content;
            applyDeckSettingsToGame(updatedDeck.settings);
            dom.currentDeckNameSpan.textContent = updatedDeck.name;
            startGame();
        }
    });

    function prettyPrintJson(jsonString) {
        try {
            const obj = JSON.parse(jsonString);
            return JSON.stringify(obj, null, 2);
        } catch (e) {
            return jsonString;
        }
    }

    dom.editJsonBtn.addEventListener('click', () => {
        if (!pendingDeckContent) {
            dom.jsonEditorTextarea.value = '';
            dom.jsonEditorTextarea.classList.remove('invalid');
            dom.jsonEditorModal.style.display = 'flex';
            return;
        }

        try {
            const contentArray = JSON.parse(pendingDeckContent);
            const cleanedContent = cleanJsonContent(contentArray);
            dom.jsonEditorTextarea.value = prettyPrintJson(JSON.stringify(cleanedContent));
        } catch (e) {
            console.error("Error cleaning and prepping JSON for editor:", e);
            dom.jsonEditorTextarea.value = pendingDeckContent;
        }
        
        dom.jsonEditorTextarea.classList.remove('invalid');
        dom.jsonEditorModal.style.display = 'flex';
    });

    dom.importJsonBtn.addEventListener('click', () => {
        dom.fileInput.click();
    });

    dom.fileInput.addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = evt => {
            importCache.content = evt.target.result;
            importCache.name = file.name;
            
            const existingContent = dom.jsonEditorTextarea.value.trim();
            if (existingContent) {
                dom.mergeModal.style.display = 'flex';
            } else {
                dom.jsonEditorTextarea.value = prettyPrintJson(importCache.content);
                pendingFileName = importCache.name;
            }
        };
        reader.readAsText(file);
        dom.fileInput.value = null;
    });

    dom.cancelMergeBtn.addEventListener('click', () => {
        dom.mergeModal.style.display = 'none';
        importCache = { content: null, name: null };
    });

    dom.overwriteBtn.addEventListener('click', () => {
        dom.jsonEditorTextarea.value = prettyPrintJson(importCache.content);
        pendingFileName = importCache.name;
        dom.mergeModal.style.display = 'none';
        importCache = { content: null, name: null };
    });

    dom.mergeBtn.addEventListener('click', () => {
        try {
            const existingArray = JSON.parse(dom.jsonEditorTextarea.value.trim());
            const newArray = JSON.parse(importCache.content);

            if (!Array.isArray(existingArray) || !Array.isArray(newArray)) {
                alert('Ambos os conte√∫dos (existente e novo) devem ser arrays JSON.');
                return;
            }
            
            const mergedArray = [...existingArray];
            const existingQuestions = new Set(existingArray.map(item => (item.question || "").trim() + "::" + (item.answer || "").trim()));
            
            let addedCount = 0;
            newArray.forEach(item => {
                const q = (item.question || "").trim();
                const a = (item.answer || "").trim();
                const key = q + "::" + a;
                
                if (q && a && !existingQuestions.has(key)) {
                    mergedArray.push({ 
                        question: q, 
                        answer: a, 
                        contexts: item.contexts || [] 
                    });
                    existingQuestions.add(key);
                    addedCount++;
                }
            });
            
            dom.jsonEditorTextarea.value = JSON.stringify(mergedArray, null, 2);
            pendingFileName = 'Conte√∫do Mesclado';
            alert(`${addedCount} novos itens adicionados.`);
        } catch (e) {
            alert('Erro ao mesclar: JSON inv√°lido. ' + e.message);
        }
        
        dom.mergeModal.style.display = 'none';
        importCache = { content: null, name: null };
    });

    dom.cancelJsonBtn.addEventListener('click', () => {
        dom.jsonEditorModal.style.display = 'none';
        dom.jsonEditorTextarea.classList.remove('invalid');
    });

    dom.saveJsonBtn.addEventListener('click', () => {
        const content = dom.jsonEditorTextarea.value;
        if (!content.trim()) {
            pendingDeckContent = null;
            pendingFileName = "Nenhum";
            dom.fileNameSpan.textContent = pendingFileName;
            dom.jsonEditorModal.style.display = 'none';
            return;
        }

        try {
            const data = JSON.parse(content);
            if (!Array.isArray(data)) {
                throw new Error('O JSON principal deve ser um array `[]`.');
            }
            
            const cleanedData = cleanJsonContent(data);
            pendingDeckContent = JSON.stringify(cleanedData);

            if (!pendingFileName || pendingFileName === "Nenhum") {
                pendingFileName = "Conte√∫do Editado";
            }
            dom.fileNameSpan.textContent = pendingFileName;
            
            dom.jsonEditorTextarea.classList.remove('invalid');
            dom.jsonEditorModal.style.display = 'none';
        } catch (e) {
            dom.jsonEditorTextarea.classList.add('invalid');
            alert('JSON inv√°lido! Verifique o formato.\n\nErro: ' + e.message);
        }
    });

    function populateVoices() {
        const voices = speechSynthesis.getVoices();
        dom.voiceSelect.innerHTML = '<option value="none">Nenhuma</option>';
        voices.forEach((voice, index) => {
            const opt = document.createElement('option');
            opt.value = index;
            opt.textContent = `${voice.name} (${voice.lang})`;
            dom.voiceSelect.appendChild(opt);
        });
    }
    
    speechSynthesis.onvoiceschanged = populateVoices;

    function initSpeechRecognition() {

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
            console.warn('Speech Recognition API not supported');
            return;
        }

        recognition = new SpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = true


        recognition.onresult = (event) => {
            if (!isRecognizing){
                return
            }
            const transcript = event.results[event.results.length - 1][0].transcript;

            if (translationElement) {
                translationElement.textContent = transcript;
                translationElement.dataset.isHint = 'false';
                
                let found = false
                transcript.split(" ").forEach(word=>{
                    found = samePronunciation(currentSyllable.question, word)
                })

                
                if (found) {
                    hintUsed = false
                    if (!hintUsed) {
                        if (correctSoundEnabled) {
                            correctSound.currentTime = 0;
                            correctSound.play();
                        }
                        if (currentSyllableElement) {
                            createParticle(currentSyllableElement);
                        }
                        score++;
                        updateScoreDisplay();
                        currentGroup.splice(currentSyllable.pickIndex, 1);

                        if (currentGroup.length === 0) {
                            currentGroupIndex++;
                            loadGroup(currentGroupIndex);
                        }

                        translationElement.textContent = '';
                        currentSyllableElement.remove();
                        stopRecognition()
                        displaySyllable();
                    }
                }
            }
        };

        recognition.onend = () => {
            isRecognizing = false;
            if (pronunciationModeEnabled && currentSyllable && dom.congratsModal.style.display !== 'flex') {
                startRecognition();
            }
        };

        recognition.onerror = (event) => {
            console.error('Speech recognition error:', event.error);
            isRecognizing = false;
        };
    }

    function startRecognition() {
        if (!recognition || !pronunciationModeEnabled || isRecognizing) return;
        
        try {
            recognition.lang = selectedVoice ? selectedVoice.lang : 'en-US';

            recognition.start();
            isRecognizing = true;
            translationElement.textContent = ''
        } catch (e) {
            if (e.name !== 'InvalidStateError') {
                console.error('Error starting recognition:', e);
            }
            isRecognizing = false;
        }
    }

    function stopRecognition() {
        if (recognition && isRecognizing) {
            try {
                recognition.stop();
            } catch (e) {
                console.error('Error stopping recognition:', e);
            }
            isRecognizing = false;
        }
    }

    function selectVoice() {
        if (dom.voiceSelect.value === 'none') {
            selectedVoice = null;
            utterance = null;
            return;
        }

        selectedVoice = speechSynthesis.getVoices()[dom.voiceSelect.value];
        utterance = new SpeechSynthesisUtterance();
        utterance.voice = selectedVoice;

        if (recognition && selectedVoice) {
            recognition.lang = selectedVoice.lang;
        }

        if (currentSyllable?.question && !pronunciationModeEnabled) {
            utterance.text = currentSyllable.question;
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }
            speechSynthesis.speak(utterance);
        }
        initSpeechRecognition()
        startRecognition()
    }
    
    dom.voiceSelect.addEventListener('change', () => {
        selectVoice();
        if (currentDeckId) {
            saveCurrentDeckSettings();
        }
    });

    function hashCode(str) {
        let hash = 2166136261;
        for (let i = 0; i < str.length; i++) {
            hash ^= str.charCodeAt(i);
            hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
        }
        return Math.abs(hash >>> 0);
    }

    function generateColor(str) {
        const hash = hashCode(str);
        const hue = (hash * 137) % 360;
        const saturation = 85 + (hash % 15);
        const lightness = darkModeEnabled ? 60 + (hash % 16) : 35 + (hash % 16);
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function generatePosition(str) {
        const hash = hashCode(str);
        const marginTop = 80;
        const marginBottom = 150;
        const marginLeft = 100;
        const marginRight = 100;
        
        const tempEl = document.createElement('div');
        tempEl.classList.add('syllable');
        tempEl.textContent = str;
        tempEl.style.visibility = 'hidden';
        tempEl.style.position = 'absolute';
        document.body.appendChild(tempEl);
        
        const elWidth = tempEl.offsetWidth;
        const elHeight = tempEl.offsetHeight;
        document.body.removeChild(tempEl);

        const maxX = window.innerWidth - marginRight - elWidth;
        const maxY = window.innerHeight - marginBottom - elHeight;
        const minX = marginLeft;
        const minY = marginTop;

        const rangeX = Math.max(1, maxX - minX + 1);
        const rangeY = Math.max(1, maxY - minY + 1);

        let x = minX + (Math.abs(hash) % rangeX);
        let y = minY + (Math.abs(hash >> 8) % rangeY);

        x = Math.min(Math.max(x, minX), maxX);
        y = Math.min(Math.max(y, minY), maxY);

        return { x, y };
    }
    
    function updateScoreDisplay() {
        const deck = allDecks.find(d => d.id === currentDeckId);
        if (!deck) return;

        if (evaluativeModeEnabled) {
            const stats = calculateDeckStats(deck.content);
            dom.scoreText.textContent = `| Pontua√ß√£o: ${score} | Novas: ${stats.newCount} | Revis√£o: ${stats.dueCount + sessionReviewQueue.length}`;
        } else {
            const totalLevels = Math.ceil(syllableList.length / groupSize);
            dom.scoreText.textContent = `| Pontua√ß√£o: ${score} | Level: ${currentGroupIndex + 1} / ${totalLevels}`;
        }
    }

    function showCongrats(isFsrs = false) {
        const originalEvalMode = evaluativeModeEnabled;
        
        if (isFsrs) {
            dom.congratsMessage.textContent = "N√£o h√° cart√µes novos ou para revisar no momento! Retornando ao Modo Livre.";
            evaluativeModeEnabled = false; // Muda para modo livre
            pronunciationModeEnabled = false;
        } else {
            dom.congratsMessage.textContent = "Voc√™ terminou o jogo!!!";
        }
        
        dom.congratsModal.style.display = 'flex';
        
        const closeModal = () => {
            dom.congratsModal.style.display = 'none';
            document.removeEventListener('keydown', onKeyDown);
            
            // Se veio do FSRS, aplica a mudan√ßa para modo livre
            if (isFsrs) {
                const deck = allDecks.find(d => d.id === currentDeckId);
                if (deck) {
                    deck.settings.evaluativeModeEnabled = false;
                    deck.settings.pronunciationModeEnabled = false;
                    applyDeckSettingsToGame(deck.settings);
                    saveDecks();
                }
            }
            startGame();
        };
        
        dom.restartBtn.onclick = closeModal;
        const onKeyDown = (e) => {
            if (e.key === 'Enter') closeModal();
        };
        document.addEventListener('keydown', onKeyDown);
    }

    function loadGroup(index) {
        const start = index * groupSize;
        currentGroup = syllableList.slice(start, start + groupSize);

        if (currentGroup.length === 0 && syllableList.length > 0 && !evaluativeModeEnabled) {
            showCongrats(false);
        }
    }

    let lastPickedIndex = -1;
    function pickRandomSyllable() {
        if (currentGroup.length === 0) {
            currentGroupIndex++;
            loadGroup(currentGroupIndex);
        }
        if (currentGroup.length === 0) return null;

        let randomIndex;
        do {
            randomIndex = Math.floor(Math.random() * currentGroup.length);
        } while (currentGroup.length > 1 && randomIndex === lastPickedIndex);

        lastPickedIndex = randomIndex;
        return { syllable: currentGroup[randomIndex], index: randomIndex };
    }

    function displaySyllable() {
        userTyped = '';
        hintUsed = false;
        
        let picked = null;
        
        if (evaluativeModeEnabled) {
            currentSyllable = pickFsrsCard();
            if (!currentSyllable) {
                showCongrats(true);
                return;
            }
        } else {
            picked = pickRandomSyllable();
            if (!picked) return;
            currentSyllable = picked.syllable;
            currentSyllable.pickIndex = picked.index;
        }

        if (currentSyllable.contexts && currentSyllable.contexts.length > 0 && !pronunciationModeEnabled) {
            const randomIndex = Math.floor(Math.random() * currentSyllable.contexts.length);
            const contextHTML = currentSyllable.contexts[randomIndex].replace(/\*\*(.*?)\*\*/g, '<high>$1</high>');
            dom.contextHintText.innerHTML = contextHTML;
            dom.contextHintBox.style.display = 'flex';
        } else {
            dom.contextHintBox.style.display = 'none';
        }

        if (selectedVoice && utterance && !pronunciationModeEnabled) {
            utterance.text = currentSyllable.question;
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }
            speechSynthesis.speak(utterance);
        }

        if (currentSyllableElement) currentSyllableElement.remove();
        
        const syllableEl = document.createElement('div');
        syllableEl.classList.add('syllable');
        syllableEl.style.position = 'relative';

        translationElement = document.createElement('span');
        translationElement.classList.add('translation');
        translationElement.textContent = '';
        
        if (evaluativeModeEnabled) {
            syllableEl.style.color = 'inherit';
            syllableEl.textContent = currentSyllable.question;
            translationElement.style.color = 'inherit';
            
            syllableEl.style.left = '50%';
            syllableEl.style.top = '50%';
            syllableEl.style.transform = 'translate(-50%, -50%)';
        } else { // Modo Livre ou Pron√∫ncia (no modo pron√∫ncia o texto tbm √© s√≥ a pergunta)
            const color = generateColor(currentSyllable.question);
            const hintColor = (colorHintEnabled && !pronunciationModeEnabled) ? color : 'inherit';
            syllableEl.style.color = hintColor;
            translationElement.style.color = hintColor;

            let placeholder = currentSyllable.answer.length - answerTipLetters > 0 ? "~" : "";
            if (answerTipLetters > 0 && !pronunciationModeEnabled) {
                syllableEl.textContent = currentSyllable.question + " ‚Üí " + currentSyllable.answer.substring(0, answerTipLetters) + placeholder;
            } else {
                syllableEl.textContent = currentSyllable.question;
            }
            
            if (positionHintEnabled && !pronunciationModeEnabled) {
                const { x, y } = generatePosition(syllableEl.textContent);
                syllableEl.style.left = x + 'px';
                syllableEl.style.top = y + 'px';
            } else {
                syllableEl.style.left = '50%';
                syllableEl.style.top = '50%';
                syllableEl.style.transform = 'translate(-50%, -50%)';
            }
        }

        syllableEl.appendChild(translationElement);
        currentSyllableElement = syllableEl;
        document.body.appendChild(syllableEl);

        if (pronunciationModeEnabled) {
            setTimeout(startRecognition, 200)
        }
    }

    function shuffle(lista) {
        for (let i = lista.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [lista[i], lista[j]] = [lista[j], lista[i]];
        }
        return lista;
    }

    function startGame() {
        if (syllableList.length === 0) return;

        selectVoice();
        currentSyllable = null;
        if (currentSyllableElement) currentSyllableElement.remove();
        if (translationElement) translationElement.remove();
        dom.contextHintBox.style.display = 'none';
        
        score = 0;
        sessionReviewQueue = [];

        if (selectedVoice && recognition) {
            recognition.lang = selectedVoice.lang;
        } else if (recognition) {
            recognition.lang = 'en-US';
        }

        if (evaluativeModeEnabled) {
            currentGroupIndex = 0;
            currentGroup = [];
            cardStartTime = Date.now();
        } else { // Modo Livre ou Pron√∫ncia
            currentGroupIndex = 0;
            currentGroup = [];
            if (randomToggleEnabled) {
                syllableList = shuffle([...syllableList]);
            }
            loadGroup(currentGroupIndex);
        }

        updateScoreDisplay();
        displaySyllable();
    }
    
    function createParticle(element) {
        const rect = element.getBoundingClientRect();
        const particle = document.createElement('div');
        particle.style.position = 'fixed';
        particle.style.left = (rect.left + rect.width / 2 - 4) + 'px';
        particle.style.top = rect.top + 'px';
        particle.style.width = '10px';
        particle.style.height = '10px';
        particle.style.backgroundColor = element.style.color || 'var(--primary)';
        particle.style.borderRadius = '0';
        particle.style.zIndex = '100000';
        particle.style.opacity = '1';
        particle.style.pointerEvents = 'none';
        document.body.appendChild(particle);

        let posY = rect.top;
        const speed = 15 + Math.random() * 2;
        function fall() {
            posY += speed;
            particle.style.top = posY + 'px';
            particle.style.opacity = 1 - posY / window.innerHeight;
            if (posY > window.innerHeight) {
                particle.remove();
            } else {
                requestAnimationFrame(fall);
            }
        }
        requestAnimationFrame(fall);
    }

    // --- Event Listeners das Configura√ß√µes ---

    // Listeners de Configs Globais
    dom.generalSettingsBtn.addEventListener('click', () => {
        dom.generalSettingsModal.style.display = 'flex';
    });
    
    dom.closeGeneralSettingsBtn.addEventListener('click', () => {
        saveGlobalSettings(); // Salva ao fechar
        dom.generalSettingsModal.style.display = 'none';
    });

    dom.generalCorrectSoundToggle.addEventListener('change', saveGlobalSettings);
    dom.generalWrongSoundToggle.addEventListener('change', saveGlobalSettings);
    dom.generalDarkModeToggle.addEventListener('change', saveGlobalSettings);

    // Listeners de Configs do Deck
    function setupDeckSettingToggle(toggle, callback) {
        toggle.addEventListener('change', () => {
            callback(toggle.checked);
            saveCurrentDeckSettings();
        });
    }

    setupDeckSettingToggle(dom.restartOnWrongToggle, (val) => restartOnWrongEnabled = val);
    
    dom.answerTipRange.addEventListener('input', () => {
        answerTipLetters = parseInt(dom.answerTipRange.value);
        dom.answerTipValue.textContent = answerTipLetters;
        saveCurrentDeckSettings();
        if (currentSyllable && !evaluativeModeEnabled) {
            displaySyllable();
        }
    });

    setupDeckSettingToggle(dom.randomToggle, (val) => {
        randomToggleEnabled = val;
        if (currentSyllable && !evaluativeModeEnabled) startGame();
    });

    setupDeckSettingToggle(dom.colorHintToggle, (val) => {
        colorHintEnabled = val;
        if (currentSyllable && !evaluativeModeEnabled) displaySyllable();
    });

    setupDeckSettingToggle(dom.positionHintToggle, (val) => {
        positionHintEnabled = val;
        if (currentSyllable && !evaluativeModeEnabled) displaySyllable();
    });

    // Novos Listeners de Modo de Jogo
    const modeToggles = [dom.modeFreeToggle, dom.modeFsrsToggle, dom.modePronunciationToggle];
    
    function handleModeChange(e) {
        const selectedToggle = e.target;
        
        // Garante que o selecionado fique checado
        if (!selectedToggle.checked) {
            selectedToggle.checked = true;
            return; // Impede desmarcar o √∫ltimo
        }

        // Desmarca os outros
        modeToggles.forEach(toggle => {
            if (toggle !== selectedToggle) {
                toggle.checked = false;
            }
        });
        
        // Atualiza a visibilidade das configs do Modo Livre
        updateModeSettingsVisibility();

        // Salva e reinicia o jogo
        evaluativeModeEnabled = dom.modeFsrsToggle.checked;
        pronunciationModeEnabled = dom.modePronunciationToggle.checked;
        saveCurrentDeckSettings();
        
        if (currentSyllable) {
            if (pronunciationModeEnabled) {
                if (speechSynthesis.speaking) speechSynthesis.cancel();
                startRecognition();
            } else {
                stopRecognition();
            }
            startGame();
        }
    }

    modeToggles.forEach(toggle => toggle.addEventListener('click', handleModeChange));


    // --- Outros Listeners ---

    dom.settingsBtn.addEventListener('click', () => {
        if (currentDeckId) {
            openSettingsModal(currentDeckId);
        } else {
            alert("Por favor, selecione um deck primeiro.");
            dom.deckModal.style.display = 'flex';
        }
    });
    
    dom.deckSelectBtn.addEventListener('click', () => {
        stopRecognition();
        dom.deckModal.style.display = 'flex';
        if (currentSyllableElement) currentSyllableElement.remove();
        currentSyllable = null;
        dom.contextHintBox.style.display = 'none';
        if (speechSynthesis.speaking) speechSynthesis.cancel();
    });
    
    dom.addDeckBtn.addEventListener('click', () => {
        openSettingsModal(null);
    });
    
    dom.cancelSettingsBtn.addEventListener('click', () => {
        dom.settingsModal.style.display = 'none';
    });

    dom.statsCloseBtn.addEventListener('click', () => {
        dom.statsModal.style.display = 'none';
    });

    function isModalOpen() {
        return dom.settingsModal.style.display === 'flex' || 
               dom.deckModal.style.display === 'flex' ||
               dom.jsonEditorModal.style.display === 'flex' ||
               dom.mergeModal.style.display === 'flex' ||
               dom.statsModal.style.display === 'flex' ||
               dom.congratsModal.style.display === 'flex' ||
               dom.generalSettingsModal.style.display === 'flex'; // Adiciona novo modal
    }

    function handleKeyInput(key) {
        if (pronunciationModeEnabled) return;
        if (!firstKeyTime) firstKeyTime = Date.now();
        userTyped += key;
        if (translationElement) {
            translationElement.textContent = userTyped;
        }
    }

    function handleBackspace() {
        if (pronunciationModeEnabled) return;
        userTyped = userTyped.slice(0, -1);
        if (translationElement) {
            translationElement.textContent = userTyped;
        }
    }

    function handleVoiceRepeat() {
        if (pronunciationModeEnabled) return;
        if (selectedVoice && utterance) {
            utterance.text = currentSyllable.question;
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }
            speechSynthesis.speak(utterance);
        }
    }

    function handlePronunciationEnter() {
        if (wrongSoundEnabled) {
            wrongSound.currentTime = 0;
            wrongSound.play();
        }
        
        setTimeout(() => {
            if (selectedVoice && utterance) {
                utterance.text = currentSyllable.question;
                if (speechSynthesis.speaking) {
                    speechSynthesis.cancel();
                }
                speechSynthesis.speak(utterance);
            }
        }, 200);

        if (translationElement) {
            translationElement.textContent = currentSyllable.question;
            translationElement.dataset.isHint = 'true';
        }
        
        hintUsed = true;
    }

    function handleFsrsEnter() {
        if (hintUsed) {
            hintUsed = false;
            userTyped = '';
            if (translationElement) translationElement.textContent = '';
            if (currentSyllableElement) currentSyllableElement.remove();
            displaySyllable();
            return;
        }

        const endTime = Date.now();
        const reactionTime = firstKeyTime ? firstKeyTime - cardStartTime : endTime - cardStartTime;
        const typingTime = firstKeyTime ? endTime - firstKeyTime : 0;
        firstKeyTime = 0;

        const levDistance = levenshtein(userTyped, currentSyllable.answer);
        const normalizedSim = 1 - (levDistance / Math.max(userTyped.length, currentSyllable.answer.length, 1));
        const grade = calculateGrade(normalizedSim, { reactionTime, typingTime });

        updateFsrsData(currentSyllable, grade);
        saveDecks();

        if (userTyped !== currentSyllable.answer) {
            if (wrongSoundEnabled) {
                wrongSound.currentTime = 0;
                wrongSound.play();
            }
            if (translationElement) {
                translationElement.textContent = currentSyllable.answer;
            }
            userTyped = '';
            hintUsed = true;
            sessionReviewQueue.push(currentSyllable);
            cardStartTime = Date.now();
        } else {
            if (correctSoundEnabled) {
                correctSound.currentTime = 0;
                correctSound.play();
            }
            if (currentSyllableElement) {
                createParticle(currentSyllableElement);
            }
            score++;
            if (translationElement) translationElement.textContent = '';
            if (currentSyllableElement) currentSyllableElement.remove();
            cardStartTime = Date.now();
            displaySyllable();
        }
        updateScoreDisplay();
    }

    function handleFreeModeEnter() {
        if (userTyped === currentSyllable.answer) {
            if (!hintUsed) {
                if (correctSoundEnabled) {
                    correctSound.currentTime = 0;
                    correctSound.play();
                }
                if (currentSyllableElement) {
                    createParticle(currentSyllableElement);
                }
                score++;
                updateScoreDisplay();
                currentGroup.splice(currentSyllable.pickIndex, 1);

                if (currentGroup.length === 0) {
                    currentGroupIndex++;
                    loadGroup(currentGroupIndex);
                }
            }
            if (translationElement) translationElement.textContent = '';
            if (currentSyllableElement) currentSyllableElement.remove();
            displaySyllable();
        } else {
            if (translationElement) {
                translationElement.textContent = currentSyllable.answer;
            }

            if (wrongSoundEnabled) {
                wrongSound.currentTime = 0;
                wrongSound.play();
            }
        
            userTyped = '';
            hintUsed = true;

            if (restartOnWrongEnabled) {
                setTimeout(() => {
                    alert("Voc√™ errou, Reiniciando jogo!");
                    startGame();
                }, 100);
            }
        }
    }
    
    document.addEventListener('keydown', e => {
        if (isModalOpen()) return;
        if (!currentSyllable || !currentSyllable.answer) return;

        const key = e.key.toLowerCase();

        if (/^[a-z ']$/.test(key) && key.length === 1) {
            handleKeyInput(key);
        } else if (e.key === 'Backspace') {
            handleBackspace();
        } else if (e.key === 'Control') {
            handleVoiceRepeat();
        } else if (e.key === 'Enter') {
            if (pronunciationModeEnabled) {
                handlePronunciationEnter();
            } else if (evaluativeModeEnabled) {
                handleFsrsEnter();
            } else {
                handleFreeModeEnter();
            }
        }
    });

    function init() {
        populateVoices();
        loadGlobalSettings(); // Carrega configs globais
        loadDecks();
        migrateOldData();
        renderDeckModal();
    }
    
    init();

})();
</script>
</body>
</html>